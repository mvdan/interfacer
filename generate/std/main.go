// Copyright (c) 2015, Daniel Mart√≠ <mvdan@mvdan.cc>
// See LICENSE for licensing information

package main

import (
	"fmt"
	"go/importer"
	"go/types"
	"io"
	"os"
	"sort"
	"text/template"
)

const filename = "std.go"

var tmpl = template.Must(template.New("std").Parse(`// Generated by generate/std

package main

type pkgNames struct {
	path  string
	names []string
}

var pkgs = [...]pkgNames{
{{range $_, $pkg := .}}	{
		path: "{{$pkg.Path}}",
{{if $pkg.Names}}		names: []string{
{{range $_, $name := $pkg.Names}}			"{{$name}}",
{{end}}		},
{{end}}	},
{{end}}}
`))

func fromScope(scope *types.Scope) []string {
	var wanted []string
	for _, name := range scope.Names() {
		tn, ok := scope.Lookup(name).(*types.TypeName)
		if !ok {
			continue
		}
		switch x := tn.Type().Underlying().(type) {
		case *types.Interface:
			if x.NumMethods() == 0 {
				continue
			}
		case *types.Signature:
		default:
			continue
		}
		wanted = append(wanted, name)
	}
	return wanted
}

type byLength []string

func (l byLength) Len() int {
	return len(l)
}
func (l byLength) Less(i, j int) bool {
	if len(l[i]) == len(l[j]) {
		return l[i] < l[j]
	}
	return len(l[i]) < len(l[j])
}
func (l byLength) Swap(i, j int) {
	l[i], l[j] = l[j], l[i]
}

type pkgNames struct {
	Path  string
	Names []string
}

func generate(w io.Writer) error {
	imp := importer.Default()
	fromScope(types.Universe)
	var wanted []pkgNames
	sort.Sort(byLength(pkgs))
	for _, path := range pkgs {
		scope := types.Universe
		if path != "" {
			pkg, err := imp.Import(path)
			if err != nil {
				return err
			}
			scope = pkg.Scope()
		}
		wanted = append(wanted, pkgNames{
			Path:  path,
			Names: fromScope(scope),
		})
	}
	return tmpl.Execute(w, wanted)
}

func main() {
	f, err := os.Create(filename)
	if err != nil {
		errExit(err)
	}
	defer f.Close()
	if err := generate(f); err != nil {
		errExit(err)
	}
}

func errExit(err error) {
	fmt.Fprintf(os.Stderr, "%v\n", err)
	os.Exit(1)
}
